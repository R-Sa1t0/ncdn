package l4lbdrv

// This file is auto generated by gen_bindings.go. Do not modify.

import (
	"bytes"
	"fmt"
	"strings"
	"unsafe"
)

// Source: ../c/lb.c

const (
	DESTINATIONS_SIZE = 255 // ../c/lb.c:66
)

type StatCounters struct { // ../c/lb.c:28
	RxPacketTotal                uint64 // ../c/lb.c:29
	RxTotalSize                  uint64 // ../c/lb.c:30
	TooShortPacketTotal          uint64 // ../c/lb.c:32
	NonIpv4PacketTotal           uint64 // ../c/lb.c:33
	IpOptionPacketTotal          uint64 // ../c/lb.c:34
	NonSupportedProtoPacketTotal uint64 // ../c/lb.c:35
	NoVipMatchTotal              uint64 // ../c/lb.c:36
	FailedAdjustHeadTotal        uint64 // ../c/lb.c:37
	FailedAdjustTailTotal        uint64 // ../c/lb.c:38
}

func StatCountersAssertLayout(s *DWARFStruct) error {
	if s == nil {
		return fmt.Errorf("DWARFStruct is nil")
	}

	gosize := unsafe.Sizeof(StatCounters{})
	if gosize != uintptr(s.Size) {
		return fmt.Errorf("size mismatch: go: %d, dwarf: %d", gosize, s.Size)
	}

	fs := s.Fields

	var goff uintptr
	var doff int64
	goff = unsafe.Offsetof(StatCounters{}.RxPacketTotal)
	doff = fs["rx_packet_total"].Offset
	if goff != uintptr(doff) {
		return fmt.Errorf("offset mismatch: go RxPacketTotal: %d, dwarf rx_packet_total: %d", goff, doff)
	}
	goff = unsafe.Offsetof(StatCounters{}.RxTotalSize)
	doff = fs["rx_total_size"].Offset
	if goff != uintptr(doff) {
		return fmt.Errorf("offset mismatch: go RxTotalSize: %d, dwarf rx_total_size: %d", goff, doff)
	}
	goff = unsafe.Offsetof(StatCounters{}.TooShortPacketTotal)
	doff = fs["too_short_packet_total"].Offset
	if goff != uintptr(doff) {
		return fmt.Errorf("offset mismatch: go TooShortPacketTotal: %d, dwarf too_short_packet_total: %d", goff, doff)
	}
	goff = unsafe.Offsetof(StatCounters{}.NonIpv4PacketTotal)
	doff = fs["non_ipv4_packet_total"].Offset
	if goff != uintptr(doff) {
		return fmt.Errorf("offset mismatch: go NonIpv4PacketTotal: %d, dwarf non_ipv4_packet_total: %d", goff, doff)
	}
	goff = unsafe.Offsetof(StatCounters{}.IpOptionPacketTotal)
	doff = fs["ip_option_packet_total"].Offset
	if goff != uintptr(doff) {
		return fmt.Errorf("offset mismatch: go IpOptionPacketTotal: %d, dwarf ip_option_packet_total: %d", goff, doff)
	}
	goff = unsafe.Offsetof(StatCounters{}.NonSupportedProtoPacketTotal)
	doff = fs["non_supported_proto_packet_total"].Offset
	if goff != uintptr(doff) {
		return fmt.Errorf("offset mismatch: go NonSupportedProtoPacketTotal: %d, dwarf non_supported_proto_packet_total: %d", goff, doff)
	}
	goff = unsafe.Offsetof(StatCounters{}.NoVipMatchTotal)
	doff = fs["no_vip_match_total"].Offset
	if goff != uintptr(doff) {
		return fmt.Errorf("offset mismatch: go NoVipMatchTotal: %d, dwarf no_vip_match_total: %d", goff, doff)
	}
	goff = unsafe.Offsetof(StatCounters{}.FailedAdjustHeadTotal)
	doff = fs["failed_adjust_head_total"].Offset
	if goff != uintptr(doff) {
		return fmt.Errorf("offset mismatch: go FailedAdjustHeadTotal: %d, dwarf failed_adjust_head_total: %d", goff, doff)
	}
	goff = unsafe.Offsetof(StatCounters{}.FailedAdjustTailTotal)
	doff = fs["failed_adjust_tail_total"].Offset
	if goff != uintptr(doff) {
		return fmt.Errorf("offset mismatch: go FailedAdjustTailTotal: %d, dwarf failed_adjust_tail_total: %d", goff, doff)
	}

	return nil
}

func (c *StatCounters) Add(other *StatCounters) {
	c.RxPacketTotal += other.RxPacketTotal
	c.RxTotalSize += other.RxTotalSize
	c.TooShortPacketTotal += other.TooShortPacketTotal
	c.NonIpv4PacketTotal += other.NonIpv4PacketTotal
	c.IpOptionPacketTotal += other.IpOptionPacketTotal
	c.NonSupportedProtoPacketTotal += other.NonSupportedProtoPacketTotal
	c.NoVipMatchTotal += other.NoVipMatchTotal
	c.FailedAdjustHeadTotal += other.FailedAdjustHeadTotal
	c.FailedAdjustTailTotal += other.FailedAdjustTailTotal
}

func (c *StatCounters) String() string {
	var buf bytes.Buffer
	buf.WriteString("StatCounters{")
	if c.RxPacketTotal != 0 {
		buf.WriteString(fmt.Sprintf("RxPacketTotal=%d, ", c.RxPacketTotal))
	}
	if c.RxTotalSize != 0 {
		buf.WriteString(fmt.Sprintf("RxTotalSize=%d, ", c.RxTotalSize))
	}
	if c.TooShortPacketTotal != 0 {
		buf.WriteString(fmt.Sprintf("TooShortPacketTotal=%d, ", c.TooShortPacketTotal))
	}
	if c.NonIpv4PacketTotal != 0 {
		buf.WriteString(fmt.Sprintf("NonIpv4PacketTotal=%d, ", c.NonIpv4PacketTotal))
	}
	if c.IpOptionPacketTotal != 0 {
		buf.WriteString(fmt.Sprintf("IpOptionPacketTotal=%d, ", c.IpOptionPacketTotal))
	}
	if c.NonSupportedProtoPacketTotal != 0 {
		buf.WriteString(fmt.Sprintf("NonSupportedProtoPacketTotal=%d, ", c.NonSupportedProtoPacketTotal))
	}
	if c.NoVipMatchTotal != 0 {
		buf.WriteString(fmt.Sprintf("NoVipMatchTotal=%d, ", c.NoVipMatchTotal))
	}
	if c.FailedAdjustHeadTotal != 0 {
		buf.WriteString(fmt.Sprintf("FailedAdjustHeadTotal=%d, ", c.FailedAdjustHeadTotal))
	}
	if c.FailedAdjustTailTotal != 0 {
		buf.WriteString(fmt.Sprintf("FailedAdjustTailTotal=%d, ", c.FailedAdjustTailTotal))
	}
	if strings.HasSuffix(buf.String(), ", ") {
		buf.Truncate(buf.Len() - 2)
	}
	buf.WriteString("}")
	return buf.String()
}

type LbConfig struct { // ../c/lb.c:49
	VipAddress uint32 // ../c/lb.c:50
	NumDests   uint32 // ../c/lb.c:51
}

func LbConfigAssertLayout(s *DWARFStruct) error {
	if s == nil {
		return fmt.Errorf("DWARFStruct is nil")
	}

	gosize := unsafe.Sizeof(LbConfig{})
	if gosize != uintptr(s.Size) {
		return fmt.Errorf("size mismatch: go: %d, dwarf: %d", gosize, s.Size)
	}

	fs := s.Fields

	var goff uintptr
	var doff int64
	goff = unsafe.Offsetof(LbConfig{}.VipAddress)
	doff = fs["vip_address"].Offset
	if goff != uintptr(doff) {
		return fmt.Errorf("offset mismatch: go VipAddress: %d, dwarf vip_address: %d", goff, doff)
	}
	goff = unsafe.Offsetof(LbConfig{}.NumDests)
	doff = fs["num_dests"].Offset
	if goff != uintptr(doff) {
		return fmt.Errorf("offset mismatch: go NumDests: %d, dwarf num_dests: %d", goff, doff)
	}

	return nil
}

func LbAssertLayout(m map[string]*DWARFStruct) error {
	if err := StatCountersAssertLayout(m["stat_counters"]); err != nil {
		return fmt.Errorf("stat_counters: %v", err)
	}
	if err := LbConfigAssertLayout(m["lb_config"]); err != nil {
		return fmt.Errorf("lb_config: %v", err)
	}
	return nil
}
