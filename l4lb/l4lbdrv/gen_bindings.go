//go:build ignore

// Parse XDP driver C source files with `go:` annotations, and generate its Go
// bindings.

package main

import (
	"bufio"
	"bytes"
	"fmt"
	"log"
	"os"
	"path"
	"regexp"
	"strconv"
	"strings"
	"text/template"
	"unicode"
)

type CField struct {
	Name       string
	Type       string
	Size       int
	ArraySize  int
	SourceLine string
}

func parseCField(typ, name, arraySize, promh, sourceLine string) (CField, error) {
	var nArraySize int
	var err error
	if arraySize != "" {
		nArraySize, err = strconv.Atoi(arraySize)
		if err != nil {
			return CField{}, fmt.Errorf("Failed to parse arraySize %s: %v", arraySize, err)
		}
		if nArraySize <= 0 {
			return CField{}, fmt.Errorf("Invalid arraySize %s", arraySize)
		}
	}

	f := CField{
		Name: name,
		// Type is set later
		// Size is set later
		ArraySize:  nArraySize,
		SourceLine: sourceLine,
	}

	switch typ {
	case "uint8_t":
		f.Type = "uint"
		f.Size = 1
	case "uint16_t":
		f.Type = "uint"
		f.Size = 2
	case "uint32_t":
		f.Type = "uint"
		f.Size = 4
	case "uint64_t":
		f.Type = "uint"
		f.Size = 8
	default:
		return CField{}, fmt.Errorf("Unknown type: %s", typ)
	}

	return f, nil
}

type CStruct struct {
	Name       string
	Fields     []CField
	SourceLine string

	DeriveAdd    bool
	DeriveEquals bool
	DeriveString bool
}

type CConst struct {
	Name       string
	Value      int
	SourceLine string
}

type CFile struct {
	Filename string
	CStructs []CStruct
	CConsts  []CConst
}

type Parsed struct {
	CFiles []*CFile
}

type ParserState int

const (
	ParserStateNoExtract ParserState = iota // Not extracting any metadata
	ParserStateStruct                       // Parsing a struct
)

func (s ParserState) String() string {
	switch s {
	case ParserStateNoExtract:
		return "NoExtract"
	case ParserStateStruct:
		return "Struct"
	default:
		return fmt.Sprintf("Unknown(%d)", s)
	}
}

var reDefineConst = regexp.MustCompile(`#define (\w+) (\d+) .*go:([\w,]*)`)
var reStructBegin = regexp.MustCompile(`\s*struct (\w+)\s*\{.*go:([\w,]*)`)
var reStructField = regexp.MustCompile(`\s*(?:struct )?(\w+)\s+(\w+)(?:\[(\d+)\])?\s*;(?:\s*\/\/ HELP (.*))?`)
var reStructEnd = regexp.MustCompile(`\s*}`)

func parseCSource(filename string) (*CFile, error) {
	parsed := CFile{Filename: filename}

	f, err := os.Open(filename)
	if err != nil {
		return nil, err
	}
	defer f.Close()

	scanner := bufio.NewScanner(f)

	// Initialize the parser state
	state := ParserStateNoExtract
	sourceLineNum := 0
	sourceLine := func() string {
		return fmt.Sprintf("%s:%d", filename, sourceLineNum)
	}
	currentStruct := CStruct{}

	for scanner.Scan() {
		line := scanner.Text()
		sourceLineNum++

		// log.Printf("%s: state=%v", sourceLine(), state)
		switch state {
		case ParserStateNoExtract:
			if ms := reDefineConst.FindStringSubmatch(line); len(ms) > 0 {
				name := ms[1]
				value, err := strconv.Atoi(ms[2])
				if err != nil {
					return nil, fmt.Errorf("%s: Failed to parse value %s: %v", sourceLine(), ms[2], err)
				}

				parsed.CConsts = append(parsed.CConsts, CConst{
					Name:       name,
					Value:      value,
					SourceLine: sourceLine(),
				})
				continue
			}

			ms := reStructBegin.FindStringSubmatch(line)
			if len(ms) < 3 {
				continue
			}
			cname := ms[1]
			directives := strings.Split(ms[2], ",")

			state = ParserStateStruct
			currentStruct = CStruct{
				Name:       cname,
				SourceLine: sourceLine(),
			}
			for _, d := range directives {
				switch d {
				case "Add":
					currentStruct.DeriveAdd = true
				case "Equals":
					currentStruct.DeriveEquals = true
				case "String":
					currentStruct.DeriveString = true
				case "":
					break
				default:
					return nil, fmt.Errorf("%s: Unknown directive %q", sourceLine(), d)
				}
			}

		case ParserStateStruct:
			if reStructEnd.MatchString(line) {
				state = ParserStateNoExtract
				parsed.CStructs = append(parsed.CStructs, currentStruct)
				currentStruct = CStruct{}
				continue
			}

			ms := reStructField.FindStringSubmatch(line)
			if len(ms) < 5 {
				continue
			}
			typ, name, arraySize, promh := ms[1], ms[2], ms[3], ms[4]
			// log.Printf("%s: typ=%q name=%q arraySize=%q promh=%q", sourceLine(), typ, name, arraySize, promh)
			f, err := parseCField(typ, name, arraySize, promh, sourceLine())
			if err != nil {
				return nil, fmt.Errorf("%s: Failed to parse type %s: %v", sourceLine(), typ, err)
			}
			currentStruct.Fields = append(currentStruct.Fields, f)
		}
	}
	if err := scanner.Err(); err != nil {
		return nil, fmt.Errorf("bufio.Scanner failed %s: %v", filename, err)
	}

	return &parsed, nil
}

const GO_TEMPLATE = `package l4lbdrv
// This file is auto generated by gen_bindings.go. Do not modify.

import (
	"bytes"
	"fmt"
	"strings"
	"unsafe"
)

{{ range $cfile := .CFiles }}
// Source: {{ $cfile.Filename }}

const (
{{ range $c := $cfile.CConsts }}
{{ $c.Name }} = {{ $c.Value }} // {{ $c.SourceLine }}
{{- end }}{{/* .cfile.CStructs */}}
)

{{ range $s := $cfile.CStructs }}
{{ $goStructName := snakeCaseToCamelCase $s.Name }}
type {{ $goStructName }} struct { // {{ $s.SourceLine }}
	{{- range $f := $s.Fields }}
	{{ snakeCaseToCamelCase $f.Name }} {{ goType $f }} // {{ $f.SourceLine }}
	{{- end }}
}

func {{ $goStructName }}AssertLayout(s *DWARFStruct) error {
	if s == nil {
		return fmt.Errorf("DWARFStruct is nil")
	}

	gosize := unsafe.Sizeof({{ $goStructName }}{})
	if gosize != uintptr(s.Size) {
		return fmt.Errorf("size mismatch: go: %d, dwarf: %d", gosize, s.Size)
	}

	fs := s.Fields

	var goff uintptr
	var doff int64

	{{- range $f := $s.Fields }}
	goff = unsafe.Offsetof({{ $goStructName }}{}.{{ snakeCaseToCamelCase $f.Name }})
	doff = fs["{{ $f.Name }}"].Offset
	if goff != uintptr(doff) {
		return fmt.Errorf("offset mismatch: go {{ snakeCaseToCamelCase $f.Name }}: %d, dwarf {{ $f.Name }}: %d", goff, doff)
	}
	{{- end }}

	return nil
}
{{ if $s.DeriveAdd }}
func (c *{{ $goStructName }}) Add(other *{{ $goStructName }}) {
	{{- range $f := $s.Fields }}
	{{- $fname := snakeCaseToCamelCase $f.Name }}
	c.{{ $fname }} += other.{{ $fname }}
	{{- end }}
}
{{ end }}{{/* $s.DeriveAdd */}}
{{ if $s.DeriveEquals }}
func (c *{{ $goStructName }}) Equals(other *{{ $goStructName }}) bool {
	{{- range $f := $s.Fields }}
	{{- $fname := snakeCaseToCamelCase $f.Name }}
	if c.{{ $fname }} != other.{{ $fname }} { return false }
	{{- end }}
	return true
}
{{ end }}{{/* $s.DeriveEquals */}}
{{ if $s.DeriveString }}
func (c *{{ $goStructName }}) String() string {
	var buf bytes.Buffer
	buf.WriteString("{{ $goStructName }}{")
	{{- range $f := $s.Fields }}
	{{- $fname := snakeCaseToCamelCase $f.Name }}
	if c.{{ $fname }} != 0 {
		buf.WriteString(fmt.Sprintf("{{ $fname }}=%d, ", c.{{ $fname }}))
	}
	{{- end }}
	if strings.HasSuffix(buf.String(), ", ") {
		buf.Truncate(buf.Len() - 2)
	}
	buf.WriteString("}")
	return buf.String()
}
{{ end }}{{/* $s.DeriveString */}}
{{ end }}{{/* .cfile.CStructs */}}

func {{ assertLayoutsFuncName $cfile.Filename }}(m map[string]*DWARFStruct) error {
	{{- range $s := $cfile.CStructs }}
	if err := {{ snakeCaseToCamelCase $s.Name }}AssertLayout(m["{{ $s.Name }}"]); err != nil {
		return fmt.Errorf("{{ $s.Name }}: %v", err)
	}
	{{- end }}
	return nil
}
{{ end }}{{/* .CFiles */}}
`
const GO_TARGET_FILENAME = "bindings_generated.go"

func emitBindingsGo(p *Parsed) error {
	tmpl := template.New(GO_TARGET_FILENAME)
	tmpl = tmpl.Funcs(template.FuncMap{
		"goType": func(f CField) string {
			var elem string
			switch f.Type {
			case "uint":
				elem = fmt.Sprintf("uint%d", f.Size*8)
			default:
				log.Panicf("goType: Unknown type: %s", f.Type)
			}

			if f.ArraySize > 0 {
				return fmt.Sprintf("[%d]%s", f.ArraySize, elem)
			} else {
				return elem
			}
		},
		"snakeCaseToCamelCase": func(s string) string {
			var buf bytes.Buffer
			upper := true
			for _, r := range s {
				if r == '_' {
					upper = true
					continue
				}
				if upper {
					buf.WriteRune(unicode.ToUpper(r))
					upper = false
				} else {
					buf.WriteRune(r)
				}
			}
			return buf.String()
		},
		"assertLayoutsFuncName": func(filename string) string {
			basename := path.Base(filename)
			prefix := strings.TrimSuffix(basename, path.Ext(basename))
			prefix = strings.ReplaceAll(prefix, "-", "")
			prefix = strings.Title(prefix)

			return fmt.Sprintf("%sAssertLayout", prefix)
		},
	})

	if _, err := tmpl.Parse(GO_TEMPLATE); err != nil {
		return err
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, p); err != nil {
		return err
	}

	if err := os.WriteFile(GO_TARGET_FILENAME, buf.Bytes(), 0644); err != nil {
		return err
	}
	return nil
}

var SourceFiles = []string{
	"../c/lb.c",
}

func run() error {
	parsed := Parsed{}

	for _, filename := range SourceFiles {
		p, err := parseCSource(filename)
		if err != nil {
			return fmt.Errorf("Failed to parse %s: %v", filename, err)
		}

		parsed.CFiles = append(parsed.CFiles, p)
	}

	if err := emitBindingsGo(&parsed); err != nil {
		return fmt.Errorf("Failed to emit %s: %v", GO_TARGET_FILENAME, err)
	}

	return nil
}

func main() {
	if err := run(); err != nil {
		log.Printf("%v", err)
	}
}
